> # 数据结构

# 1 算法时间复杂度

## 1.1 时间复杂度定义

在执行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n)=O(f(n))。表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。

## 1.2 时间复杂度推导方法

1. 用常数1取代运行时间中的所有加法常数
2. 只保留最高阶项
3. 如果最高阶存在且不是1，则去除与这个项相乘的常数

## 1.3 时间复杂度示例

### 1.3.1 常数阶

``` c
int sum = 0, n = 100;
sum = (1+n) * n/2;
printf("%d", sum);
```

> 时间复杂度为O(1)，其执行的次数是恒定的，不会随着n的增大而增加

### 1.3.2 线性阶

``` c
int i;
for (i = 0; i < n; i++)
{
    printf("%d", i);
}
```

> 时间复杂度为O(n)，其执行次数为n次

### 1.3.3 对数阶

``` c
int count = 1;
while (count < n)
{
    count = count * 2;
}
```

> 时间复杂度为O(logn)，2^x = n，故执行次数为log2n

### 1.3.4 平方阶

``` c
int i, j;
for (i = 0; i < n; i++)
{
	for (j = 0; j < n; j++)
    {
        printf("%d", i*j);
    }
}
```

> 时间复杂度为O(n^2)，执行次数为n*n 

``` c
int i, j;
for (i = 0; i < n; i++)
{
	for (j = i; j < n; j++)
    {
        printf("%d", i*j);
    }
}
```

> 时间复杂度为O(n^2)，当i=0时，内循环执行了n次，当n=1时，执行了n-1次，......当i=n-1时，执行了1次，所以总的执行次数为：n+(n-1)+(n-2)+......+1=n(n+1)/2=(n^2)/2+n/2 

## 1.4 常见时间复杂度

| 执行次数函数     | 阶       | 非正式术语 |
| ---------------- | -------- | ---------- |
| 12               | O(1)     | 常数阶     |
| 2n+3             | O(n)     | 线性阶     |
| 3n^2+2n+1        | O(n^2)   | 平方阶     |
| 5log2n+20        | O(logn)  | 对数阶     |
| 2n+3nlog2n+19    | O(nlogn) | nlogn阶    |
| 6n^3^+2n^2^+3n+4 | O(n^3^)  | 立方阶     |
| 2^n              | O(2^n^)  | 指数阶     |

常见时间复杂度耗时排序：

> O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)  

# 2 线性表

> 线性表（List）：零个或多个数据元素的有限序列。元素之间是有序的，若存在多个元素，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有前驱和后继。

线性表 `a1, a2, a3, ..., ai-1, ai, ai+1, ..., an` `ai-1`是 `ai` 的直接前驱元素，`ai+1` 是 `ai` 的直接后继元素

<link rel="stylesheet" type="text/css" href="css/github-markdown.css">
